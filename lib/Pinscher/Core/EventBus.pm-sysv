package Pinscher::Core::EventBus;

use strict;
use AutoLoader;
use Data::Dumper;
use threads;
use threads::shared;
use Thread::Queue;
use Clone qw(clone);
use Thread::Semaphore;
use Storable qw(nfreeze thaw);
use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRWXU);
use IPC::Shareable (':lock');
use POSIX qw(ceil);

our $AUTOLOAD;
our $ebid = 1234;
our %sysvqueues;
our @retqueues;


my $MAXQSEND = 80000;


sub new
{
    my $class = shift;
    my $self_self = shift;
    my $name = shift;


    tie %sysvqueues, 'IPC::Shareable', 'svmq',
        {
            create    => 1,
            exclusive => 0,
            mode      => 0644,
            destroy   => 0,
        };

    tie $ebid, 'IPC::Shareable', 'idtq',
        {
            create    => 1,
            exclusive => 0,
            mode      => 0644,
            destroy   => 0,
        };

    tie @retqueues, 'IPC::Shareable', 'retv',
        {
            create    => 1,
            exclusive => 0,
            mode      => 0644,
            destroy   => 0,
        };

    (tied $ebid)->shlock();
    my $id = ++ $ebid;
    (tied $ebid)->shunlock();
    my $queue = msgget( $id, IPC_CREAT | S_IRWXU );
    warn "id: $id";
    $sysvqueues{ 'name' } = $id;

    my $self =
    {
        'id'		=> $id,
        'queue'		=> $queue,
        'name'		=> $name,
        'methods'       =>
                        {
                                'test'          => \&footest,
                        },
            'procedures' =>
                {
                    'test'      => \&footest,
                },
                'self'      => $self_self,
                'pre_call_trap' => undef,
                'post_call_trap' => undef,
    };
    bless $self, $class;

    $self->init_retqueues;

    return $self;
}


sub AUTOLOAD
{
        my $self = shift;
        my $type = ref($self)
                    or die "$self is not an object";

        my $name = $AUTOLOAD;
        $name =~ s/.*://;   # strip fully-qualified portion
        return $self->call_thread( $name, @_ );
}


sub init_retqueues
{
    return if ( @retqueues > 0 );

    (tied @retqueues)->shlock();
    for ( my $x = 0; $x < 50; $x ++ )
    {
        my $id = ++ $ebid;
        my $recvqueue = msgget( $id, IPC_CREAT | S_IRWXU );
        push @retqueues, $id;
    }
    (tied @retqueues)->shunlock();

}


sub get_retqueue
{
    (tied @retqueues)->shlock();
    my $id = pop @retqueues;
    (tied @retqueues)->shunlock();
    my $recvqueue = msgget( $id, IPC_CREAT | S_IRWXU );
    return ( $id, $recvqueue );
}

sub return_retqueue
{
    my ( $self, $id ) = @_;
    (tied @retqueues)->shlock();
    push @retqueues, $id;
    (tied @retqueues)->shunlock();
}


sub call_thread
{
    my $self = shift;
    my $name = shift;
    my $args = \@_;

#    print "call_thread(): $self->{name} :: $name:\n" . Dumper( $args ) . "\n\n";
#    warn "$self->{name} :: $name Semaphore down\n";
#    $self->{'semaphore'}->down();
#    warn "\t$self->{name} :: $name Enqueue & clone\n";

    my ( $retid, $id, $retqueue );

    if ( !defined $self->{'procedures'}->{$name} )
    {
         ( $id, $retqueue ) = $self->get_retqueue;
         $retid = $id;
#        (tied $ebid)->shlock();
#        $id = ++ $ebid;
#        (tied $ebid)->shunlock();
#        $recvqueue = msgget( $id, IPC_CREAT | S_IRWXU );
#        die "Can't create receiving SysV message queue: $!" if ( !$recvqueue );
    }

    (tied $ebid)->shlock();
    my $frozen_payload = nfreeze( [$name, $args, $id] );

    my $payload = pack("l! a*", 1234, $frozen_payload);
    my $paylength = length($payload);
    my $packets = $paylength / $MAXQSEND;
    msgsnd( $self->{'queue'}, $packets, 0 ) or warn "Couldn't send number of packets ($packets) to txqueue: $!";

    for ( my $x = 0; $x < $packets; $x ++ )
    {
        msgsnd( $self->{'queue'}, substr($payload, $x * $MAXQSEND, $MAXQSEND), 0 ) or warn "Couldn't send packet ($x of $packets) to $self->{name} :: $name: $!";
    }
    (tied $ebid)->shunlock();

    my $ret;
    goto call_thread_done if ( $self->{'procedures'}->{$name} );

#    warn "\t$self->{name} :: $name Dequeue reply\n";
    my ($type_rcvd, $rcvd);
    warn "Listening on $retqueue / $id";
    if ( !msgrcv($retqueue, $rcvd, 1024*1024*10, 0, 0) )
    {
        warn "Couldn't msgrcv!!!";
    }

    $self->return_retqueue( $retid );

    $packets = $rcvd;
    my $reassembled = '';
    for ( my $x = 0; $x < $packets; $x ++ )
    {
        if ( !msgrcv($retqueue, $rcvd, 1024*1024*10, 0, 0) )
        {
            warn "Couldn't msgrcv!!!";
        }
        my ($xxx, $yyy) = unpack("l! a*", $rcvd);

        $reassembled = pack( "a*a*", $reassembled, $rcvd );
    }

    warn length($reassembled);
    ($type_rcvd, $rcvd) = unpack("l! a*", $reassembled);
    $ret = thaw( $rcvd );
#    warn Dumper( $ret );

#    warn "\t$self->{name} :: $name Semaphore up\n";
#    $self->{'semaphore'}->up();

call_thread_done:
#    warn "$self->{name} :: $name Done\n";
    return $ret->[0] if defined($ret);
}

sub set_self
{
    my $self = shift;
    my $newself = shift;
    $self->{'self'} = shift;
}

sub run
{
    my $self = shift;

    while( 1 )
    {
        $self->oneiteration;
    }
}


sub oneiteration
{
        my $self = shift;

        my ( $type_rcvd, $rcvd );
        if ( !msgrcv($self->{'queue'}, $rcvd, 1024*1024, 0, 0) )
        {
            warn "Couldn't msgrcv at oneiteration()!!!";
        }

        my $packets = $rcvd;
        warn "Receiving $packets in oneiteration";
        my $reassembled = '';
        for ( my $x = 0; $x < $packets; $x ++ )
        {
            if ( !msgrcv($self->{'queue'}, $rcvd, 1024*1024*10, 0, 0) )
            {
                warn "Couldn't msgrcv!!!";
            }
            $reassembled = pack( "a*a*", $reassembled, $rcvd );
        }

        ($type_rcvd, $rcvd) = unpack("l! a*", $reassembled);
        my $message = thaw( $rcvd );

        {
                if ( scalar(@{$message}) != 3 )
                {
                    print "\n\nW T F: message is not 3:\n" . Dumper( $message ) . "\n\n";
                    next;
                }
                my $command = $message->[0];
                my $args = $message->[1];
                my $txqueue = $message->[2];

                my $procedure = 0;
                my $func = $self->{methods}->{$command};
                if ( !$func )
                {
                    $func = $self->{procedures}->{$command};
                    $procedure = 1;
                    if ( !$func )
                    {
                            die "No such function or procedure '$command'\n" . Dumper( $self->{'methods'} );
                        }
                }

                my @arguments;
                push @arguments, $self->{'self'};
                if ( ref($args) eq 'ARRAY')
                    {
                        foreach my $p ( @{$args} )
                        {
                                    push @arguments, $p;
                        }
                }
                else
                {
                        push @arguments, $args;
                }


                $self->{'pre_call_trap'}->( \@arguments )
                    if ( $self->{'pre_call_trap'} );

                my $ret = $func->( @arguments ); #@{ $self, $args } );
#               warn "      Return for $command : " . Dumper( $ret );
                $self->{'post_call_trap'}->( $self, \@arguments, $ret )
                    if ( $self->{'post_call_trap'} );
                if ( $procedure != 1 )
                {
                    $ret = 0 if !defined($ret);
                    my $frozen_payload = nfreeze( [$ret] );
                    my $sysvtxqueue = msgget( $txqueue, S_IRWXU );
                    my $payload = pack("l! a*", 1234, $frozen_payload);
                    my $paylength = length($payload);

                    my $packets = $paylength / $MAXQSEND;
                    msgsnd( $sysvtxqueue, $packets, 0 ) or warn "Couldn't send number of packets ($packets) to txqueue: $!";

                    warn "Sending to $sysvtxqueue";

                    for ( my $x = 0; $x < $packets; $x ++ )
                    {
                        my $packet = substr($payload, $x * $MAXQSEND, $MAXQSEND);
                        $packet = pack("l! a*", 1234, $packet);
                        warn Dumper( [$sysvtxqueue, length($packet), 0] );
                        if( !msgsnd( $sysvtxqueue, $packet, 0 ) ) { die "Couldn't send packet ($x of $packets) to txqueue ($sysvtxqueue): $!"; }
                    }


#                    $txqueue->enqueue( threads::shared::shared_clone($ret) );
                }
        }
}

sub footest
{
        my $self = shift;
        my ( $a, $b, $c ) = @_;
        return $a + $b + $c;
}


1;
