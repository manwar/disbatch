#!/usr/bin/env perl

# USAGE: ./bin/task_runner --host localhost --db disbatch300 --plugin Disbatch::Plugin::Dummy::Task --task 565bc0d43fb6ecd1c8504492

# FIXME: Use the queue _id in the task to get the plugin name. Gotcha: WorkerThread has mongo setup, but wants the plugin name.
#        $workerthread->mongo->get_collection('queues')->find_one({_id => $doc->{queue}})->{constructor}
# FIXME: Do we need to even pass the queue _id at all? The task _id is unique, and the task contains the queue _id.

use 5.12.0;
use warnings;

use lib 'lib';	# FIXME: this is only needed for dev

use Cpanel::JSON::XS;
use Data::Dumper;
use Disbatch::Task;
use Getopt::Long;
use MongoDB::OID 1.0.0;
use Sys::Hostname;
use Try::Tiny::Retry;
#use Safe::Isa;

my ($host, $db, $queue, $task_id, $plugin, $log4perl);

GetOptions(
    'host=s'     => \$host,
    'db=s'       => \$db,
    'queue=s'    => \$queue,
    'task=s'     => \$task_id,
    'plugin=s'   => \$plugin,
    'log4perl=s' => \$log4perl,
);

my $node = hostname;
my $json = Cpanel::JSON::XS->new->utf8;

my $config = { mongohost => $host, mongodb => $db };
$config->{log4perl} = try { $json->decode($log4perl) } if defined $log4perl;

my $taskrunner = Disbatch::Task->new(class => $plugin, config => $config, task_id => $task_id);
my $logger = $taskrunner->logger;

$logger->info("Starting task $task_id");

$logger->logdie('No --task') unless defined $task_id;
$logger->logdie('No --host') unless defined $host;
$logger->logdie('No --db') unless defined $db;
$logger->logdie('No --plugin') unless defined $plugin;
#$logger->logdie('No --queue') unless defined $queue;
$logger->logdie("--plugin value '$plugin' must be a valid perl package name, matching /^[\\w:]+\$/") unless $plugin =~ /^[\w:]+$/;
$logger->logdie("$plugin not found for task $task_id") unless eval "use $plugin; 1";

my $oid = MongoDB::OID->new(value => $task_id);
my $tasks = $taskrunner->mongo->get_collection('tasks');
my $doc = try {
    $tasks->find_one_and_update({_id => $oid, status => -1, node => $node}, {'$set' => {status => 0}});
} catch {
    $logger->logdie($_);
};

$logger->logdie("No task found for $task_id") unless defined $doc;
$logger->info("parameters for $task_id: ", $json->encode($doc->{parameters}));

my $task = try {
    $plugin->new({id => $queue}, $doc->{parameters});
} catch {
    $logger->logdie($_);
};
$task->{workerthread} = $taskrunner;
$task->{id} = $oid;

my ($query, $result) = try {
    $task->run;
} catch {
    $logger->error("Thread has uncaught exception: $_");
    {queue => $queue, _id => $task_id}, {status => 2, stdout => 'Unable to complete', stderr => "Thread has uncaught exception: $_"};
};
my $status = $result->{status} == 1 ? 'succeeded' : 'failed';
$logger->info("Task $task_id $status.");
warn "STDOUT: $result->{stdout}";
warn "STDERR: $result->{stderr}";

# set status first:
retry {
    $taskrunner->tasks->update_one({_id => $oid, status => 0, node => $node}, {'$set' => {status => $result->{status}}});
    # FIXME: maybe have to test result for failure and throw?
    # die unless $res->modified_count == 1;
} catch {
    $logger->logdie("Could not update task $task_id status to $result->{status} after completion: $_");
};

$taskrunner->queues->update_one({_id => $doc->{queue}}, {'$inc' => {count_todo => -1}});

# set rest of result:
retry {
    $taskrunner->tasks->update_one({_id => $oid, status => $result->{status}, node => $node}, {'$set' => $result});
    # FIXME: maybe have to test result for failure and throw?
} on_retry {
    $result->{stdout} = 'STDOUT too large for MongoDB';
} catch {
    $logger->logdie("Could not update task $task_id stdout/stderr after completion: $_");
};
