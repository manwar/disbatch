#!/usr/bin/perl

use 5.12.0;
use warnings;

use Data::Dumper;
use Cpanel::JSON::XS;
use File::Slurp;
use Getopt::Long;
use IO::Wrap;
use LWP::UserAgent;
use Pod::Usage;
use Text::CSV_XS;
use Text::Table;
use Try::Tiny;

my $url = 'http://localhost:8080';
my $username;
my $password;
my $help = 0;
my $config_file = '/etc/disbatch/config.json';
my $ssl_ca_file;
my $disable_ssl_verification = 0;
my $collection;
my $count = 0;
my $terse = 0;
my $pretty = 0;
my $options = {};

GetOptions(
    'url|u=s'       => \$url,
    'username|n=s'  => \$username,
    'password=s'    => \$password,
    'help'          => \$help,
    'config=s'      => \$config_file,
    'ssl_ca_file=s' => \$ssl_ca_file,
    'disable_ssl_verification' => \$disable_ssl_verification,
    'collection=s'  => \$collection,
    'count'         => \$count,
    'terse'         => \$terse,
    'pretty'        => \$pretty,
    'options=s'     => \$options,
);

pod2usage(-verbose => 2, -exitval => 0) if $help;

my $json = Cpanel::JSON::XS->new->utf8;

my $ua_options = {};
if (defined $ssl_ca_file) {
    $ua_options->{ssl_opts}{SSL_ca_file} = $ssl_ca_file;
} elsif ($disable_ssl_verification) {
    $ua_options->{ssl_opts}{verify_hostname} = 0;
} else {
    # Note: the SSL settings are for MongoDB, but ideally if using SSL with MongoDB, it is also being used with the DCI
    # try loading the config file, but don't fail if it doesn't exist
    my $config = try { $json->relaxed->decode(scalar read_file $config_file) } catch { {} };
    if (defined $config->{attributes}{ssl}) {
        $ua_options->{ssl_opts} = $config->{attributes}{ssl};
        $ua_options->{ssl_opts}{verify_hostname} = $ua_options->{ssl_opts}{SSL_verify_mode} if defined $ua_options->{ssl_opts}{SSL_verify_mode};
    }
}

my $ua = LWP::UserAgent->new(%$ua_options);

if (defined $username and defined $password) {
    my ($host) = $url =~ qr{^https?://(.+?)(?:/|$)};
    $ua->credentials($host, 'disbatch', $username, $password);
    say "$host\t$username\t$password";
} elsif (defined $username or defined $password) {
    die "--username and --password must be used together\n";
}

my $command = shift @ARGV;
if ($command eq 'plugins') {
    get_plugins();
} elsif ($command eq 'queues' or $command eq 'status') {
    get_queues();
} elsif ($command eq 'create-queue') {
    post_queues();
} elsif ($command eq 'update-queue') {
    update_queue();
} elsif ($command eq 'delete-queue') {
    delete_queue();
} elsif ($command eq 'create-task') {
    post_task();
} elsif ($command eq 'create-tasks') {
    post_tasks();
} elsif ($command eq 'search') {
    post_search();
} elsif ($command) {
    die "Unknown command '$command'\n";
} else {
    pod2usage(1);
}

sub get_plugins {
    my $response = $ua->get("$url/plugins");
    if ($response->is_success) {
        my $plugins = $json->decode($response->decoded_content);
        say join "\n", @$plugins;
    } else {
        die "Error getting $url/plugins (", $response->status_line, '): ', $response->decoded_content, "\n";
    }
}

sub get_queues {
    my $response = $ua->get("$url/queues");
    if ($response->is_success) {
        my $queues = $json->decode($response->decoded_content);

        my @fields = qw/ ID Plugin Name Threads Queued Running Completed /;
        my $tl = Text::Table->new(map { { title => $_, align => 'auto' }, \' | ' } @fields);
        for my $queue (@$queues) {
            $tl->add(map { $queue->{lc $_} } @fields);
        }

        print $tl->title;		# ID                       | Plugin                                   | Name       | Threads | Queued | Running | Completed
        print $tl->rule('-', '+');	# -------------------------+------------------------------------------+------------+---------+--------+---------+----------
        say $tl->body;			# 56e1c2e1eb6af829182f4721 | Synacor::Migration::Plugins::Dummy::Task | dummy test |         | 0      | 0       | 0
					# 56eade3aeb6af81e0123ed21 |                   Disbatch::Plugin::Demo |       demo | 0       | 0      | 0       | 0
        say scalar(@$queues), ' total queues.';
    } else {
        die "Error getting $url/queues (", $response->status_line, '): ', $response->decoded_content, "\n";
    }
}

sub post_queues {
    my ($name, $plugin) = @ARGV;
    my $response = $ua->post("$url/queues", { name => $name, plugin => $plugin });
    if ($response->is_success) {
        my $result = $json->decode($response->decoded_content);
        say "Created queue $name: ", $result->{id}{'$oid'};
    } else {
        die "Error posting $url/queues (", $response->status_line, '): ', $response->decoded_content, "\n";
    }
}

sub update_queue {
    my ($queue, %data) = @ARGV;
    my $response = $ua->post("$url/queues/$queue", \%data);
    if ($response->is_success) {
        my $result = $json->decode($response->decoded_content);
        if ($result->{'MongoDB::UpdateResult'}{modified_count}) {
            say "Updated queue $queue: ", $json->encode(\%data);
        } else {
            say "No change to queue $queue: ", $json->encode(\%data);
        }
    } else {
        die "Error posting $url/queues/$queue (", $response->status_line, '): ', $response->decoded_content, "\n";
    }
}

sub delete_queue {
    my ($queue) = @ARGV;
    my $response = $ua->delete("$url/queues/$queue");
    if ($response->is_success) {
        my $result = $json->decode($response->decoded_content);
        if ($result->{'MongoDB::DeleteResult'}{deleted_count} == 1) {
            say "Deleted queue $queue";
        } else {
            die "Unknown response deleting queue $queue: ", $response->decoded_content;
        }
    } else {
        die "Error deleting $url/queues/$queue (", $response->status_line, '): ', $response->decoded_content, "\n";
    }
}

sub post_task {		# <queue> <key> <value> ...				# task params
    my ($queue, %data) = @ARGV;
    @ARGV = ($queue, $json->encode([\%data]));	# yuck
    post_tasks();
}

sub post_tasks {	# <queue> <json_array>					# JSON array of task params objects
			# --collection <collection> <queue> <json_object>	# {filter: filter, params: params}
    my ($queue, $data) = @ARGV;
    my $full_url = "$url/tasks/$queue";
    $full_url .= "/$collection" if defined $collection;
    my $response = $ua->post($full_url, 'Content-Type' => 'application/json', Content => $data // '{}');
    if ($response->is_success) {
        my $result = $json->decode($response->decoded_content);
        if ($result->{'MongoDB::InsertManyResult'}{inserted}) {
            my $count = scalar @{$result->{'MongoDB::InsertManyResult'}{inserted}};
            say "Created $count tasks in queue $queue";
            say join "\n", map { $_->{_id}{'$oid'} } @{$result->{'MongoDB::InsertManyResult'}{inserted}};
        } else {
            say "No change to queue $queue: ";
        }
    } else {
        die "Error posting $full_url (", $response->status_line, '): ', $response->decoded_content, "\n";
    }
}

sub post_search {	# <filter>						# {filter: filter, options: options, count: count, terse: terse}
    my ($filter) = @ARGV;
    my $data = $json->encode({ filter => $json->decode($filter // '{}'), count => $count, terse => $terse, pretty => $pretty, options => $options });
    my $response = $ua->post("$url/tasks/search", 'Content-Type' => 'application/json', Content => $data);
    if ($response->is_success) {
        if ($count) {
            say $json->decode($response->decoded_content)->{count}, ' tasks';
        } else {
            say $response->decoded_content;	# Array of task Objects
        }
    } else {
        die "Error posting $url/tasks/search (", $response->status_line, '): ', $response->decoded_content, "\n";
    }
}

__END__

=encoding utf8

=head1 NAME

disbatch - CLI to the Disbatch Command Interface (DCI).

=head1 SYNOPSIS

    disbatch.pl [<arguments>] <command> [<command arguments>]

=head2 ARGUMENTS

=over 2

=item --url <URL>

URL for the DCI you wish to connect to. Default is C<http://localhost:8080>.

=item --username <username>

DCI username

=item --password <password>

DCI password

=item --help

Display this message

=item --ssl_ca_file <ssl_ca_file>

Path to the SSL CA file. Needed if using SSL with a private CA.

=item --disable_ssl_verification

Disables hostname verification if SSL is used.

Only used if C<--ssl_ca_file> is not used.

=item --config <config_file>

Path to Disbatch config file. Default is C</etc/disbatch/config.json>.

Only used if neither C<--ssl_ca_file> nor C<--disable_ssl_verification> is used.

Note: the SSL settings in the Disbatch config file are for MongoDB, but ideally if using SSL with MongoDB, then it is also being used with the DCI.

=back

=head2 COMMANDS

=over 2

=item status

List all queues this disbatch server processes.

  $ disbatch.pl status
  ID                       | Type                   | Name | Threads | Done | To-Do | Processing
  -------------------------+------------------------+------+---------+------+-------+-----------
  56eade3aeb6af81e0123ed21 | Disbatch::Plugin::Demo | demo | 0       | 0    | 0     | 0

  1 total queues.

=item queue set <queue> <key> <value>

Change a field's value in a queue.
The only valid field is C<threads>.

  $ disbatch.pl queue set 56eade3aeb6af81e0123ed21 threads 10

=item queue start <type> <name>

Create a new queue.

  $ disbatch.pl queue start Disbatch::Plugin::Demo foo
  New Queue #5717f5edeb6af80362796221

=item queue task <queue> [<key> <value> ...]

Creates a task in the specified queue with the given params.

  $ ./bin/disbatch.pl queue task 5717f5edeb6af80362796221 user1 ashley user2 ashley
  [1,1,{"index":0,"_id":{"$oid":"5717f70ceb6af803671f7c71"}},{"MongoDB::InsertManyResult":{"acknowledged":1,"inserted":[{"index":0,"_id":{"$oid":"5717f70ceb6af803671f7c71"}}],"write_concern_errors":[],"write_errors":[]},"success":1}]

=item queue tasks <queue> <collection> [<filter key> <value> ...] -- -- [<param key> <value> ...]

Creates multiple tasks in the specified queue with the given params, based off a filter from another collection.

In the below example, the C<users> collection is queried for all documents matching C<{migration: "foo"}>.
These documents are then used to set task params, and the values from the query collection are accessed by prepending C<document.>.

  $ ./bin/disbatch.pl queue tasks 5717f5edeb6af80362796221 users migration foo -- -- user1 document.username user2 document.username migration document.migration
  [1,2]

=item queue search <queue> <json_query>

Returns a JSON array of task documents matching the JSON query given. Note that blessed values may be munged to be proper JSON.

$ ./bin/disbatch.pl queue search 5717f5edeb6af80362796221 '{"params.migration": "foo"}'
[{"ctime":1461189920,"stderr":null,"status":-2,"mtime":0,"_id":{"$oid":"5717fd20eb6af803671f7c72"},"node":null,"params":{"migration":"foo","user1":"ashley","user2":"ashley"},"queue":{"$oid":"5717f5edeb6af80362796221"},"stdout":null,"ctime_str":"2016-04-20T22:05:20"},{"ctime":1461189920,"stderr":null,"status":-2,"mtime":0,"_id":{"$oid":"5717fd20eb6af803671f7c73"},"node":null,"params":{"migration":"foo","user1":"matt","user2":"matt"},"queue":{"$oid":"5717f5edeb6af80362796221"},"stdout":null,"ctime_str":"2016-04-20T22:05:20"}]

=item queue types

  $ ./bin/disbatch.pl queue types
  Disbatch::Plugin::Demo

=back

=head1 SEE ALSO

L<Disbatch>

L<Disbatch::Web>

L<Disbatch::Roles>

L<Disbatch::Plugin::Demo>

L<task_runner>

L<disbatchd>

L<disbatch-create-users>

=head1 AUTHORS

Ashley Willis <awillis@synacor.com>

Matt Busigin

=head1 COPYRIGHT AND LICENSE

This software is Copyright (c) 2016 by Ashley Willis.

This is free software, licensed under:

  The Apache License, Version 2.0, January 2004
